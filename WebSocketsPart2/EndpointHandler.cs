

using System.Net.Sockets;
using System.Security.Cryptography;
using System.Text;

namespace WebSocketServer;

internal interface IEndpointHandler
{
    WebServerResponse ProcessRequest();
}

internal class SocketEndpointHandler : IEndpointHandler
{
    Endpoint _endpointDetails;
    Dictionary<string, string> _headers;
    string _body;
    NetworkStream _stream;

    public SocketEndpointHandler(NetworkStream stream, Endpoint endpointDetails)
    {
        _endpointDetails = endpointDetails;
        _stream = stream;
    }

    public WebServerResponse ProcessRequest()
    {
        // Extract Headers
        _headers = EndpointUtils.ExtractHeaders(_endpointDetails.Data);
        // Extract Body
        _body = EndpointUtils.ExtractBody(_endpointDetails.Data);
        string webSocketAcceptValue = GenerateHandShakeHeader();
        string handshakeResponse = $"""
            HTTP/1.1 101 Switching Protocols
            Upgrade: websocket
            Connection: Upgrade
            Sec-WebSocket-Accept: {webSocketAcceptValue}
        
            """;
        _stream.Write(Encoding.UTF8.GetBytes(handshakeResponse));
        while (!_stream.DataAvailable) ;
        // Read data from stream
        return null;
    }

    private string GenerateHandShakeHeader()
    {
        // Extract Sec-WebSocket-Key from headers
        if (!_headers.ContainsKey("Sec-WebSocket-Key")) throw new InvalidDataException("Sec-WebSocket-Key header missing");
        string webSocketKey = _headers["Sec-WebSocket-Key"];
        // Concat the magic string
        webSocketKey.Concat("258EAFA5-E914-47DA-95CA-C5AB0DC85B11");
        // Take SHA-1 Hash
        string webSocketKeyHash = CalculateSha1(webSocketKey);
        // return a base64 encoded form of the hash
        return Convert.ToBase64String(Encoding.UTF8.GetBytes(webSocketKeyHash));
    }

    // Generated by Bing Copilot :)
    private static string CalculateSha1(string input)
    {
        using SHA1 sha1 = SHA1.Create();
        byte[] hashBytes = sha1.ComputeHash(Encoding.UTF8.GetBytes(input));
        return BitConverter.ToString(hashBytes).Replace("-", "").ToLower();
    }

}

internal class DefaultEndpointHandler : IEndpointHandler
{
    private Endpoint endpointDetails;

    public DefaultEndpointHandler(Endpoint endpointDetails)
    {
        this.endpointDetails = endpointDetails;
    }

    public WebServerResponse ProcessRequest() => new() { Status = "HTTP/1.1 200 OK", Data = "200 OK" };
}

internal class EndpointUtils
{
    internal static string ExtractBody(string data) => data[(data.IndexOf($"{Environment.NewLine}{Environment.NewLine}") + 1)..];

    internal static Dictionary<string, string> ExtractHeaders(string data)
    {
        int headerStartIndex = data.IndexOf('\n') + 1;
        int headerEndIndex = data.IndexOf($"{Environment.NewLine}{Environment.NewLine}");
        string headers = data[headerStartIndex..headerEndIndex]; // Range Operator 🔥🔥🔥
        var headersArray = headers.Split('\n');
        Dictionary<string, string> result = [];
        foreach (var headerEntry in headersArray)
        {
            string[] tokens = headerEntry.Split(' ');
            result.Add(tokens[0].Replace(":", ""), tokens[1]);
        }
        return result;
    }
}